import com.rameses.annotations.*; 

/* ******************************************************************************************************
Notes:
The ff. are generic actions with similar related actions
1. send-for-verification = do nothing special; this action is triggered by the system when all evaluations are complete
2. send-for-revision = invoked by OBO verifier. triggers all email messages
3. reactivate - to be invoked by OBO receiving
approve - invoked by OBO Verifier. 
******************************************************************************************************* */
class BuildingPermitWorkflowInterceptor { 

	@Service("WorkflowTaskService")
	def wfSvc;

	@Service("DateService")
	def dateSvc;

	@DataContext("building_permit_section")
	def evalEm;

	@DataContext("vw_building_permit_section")
	def vwSectionEm;

	@DataContext("vw_building_permit_ancillary")
	def vwAncillaryEm;

	@DataContext("obo_section")
	def sectionEm;

	@DataContext("building_permit_requirement")
	def reqEm;

	@DataContext("building_permit")
	def appEm;

	@DataContext("building_permit_finding")
	def findingEm;

	@DataContext("building_permit_rpu")
	def rpuEm;

	@DataContext("building_permit_fee")
	def feeEm;

	@DataContext("building_permit_transmittal")
	def transmittalEm;

	@Service("OboApplicationTransmittalService")
	def transmittalSvc;

	@Service("OboApplicationService")
    def appSvc;

	/* *********************************************************************
	//Specific before action tasks
	************************************************************************ */
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-revision' }") 
	public void doActionBeforeRevision( def evt ) {
		def p = evt.args[0];
		def type = (p.to == 'requirement-revision' ) ? 'requirement' : 'finding';

		def m = [:];
		m.taskid = p.taskid;
		m.appid = p.refid;
		m.schemaname = 'building_permit';
		m.type = type;
		transmittalSvc.create( m );
	}

	//This is the part where you need to check for application specific routines
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'approve' }") 
	public void doActionBeforeApproval( def evt ) {
		def p = evt.args[0];
		if(p.taskstate.matches("requirement-verification") ) {
			//check if there are pending findings
			def t = reqEm.find( [appid: p.refid ] ).select("c:{COUNT(*)}").where("state=2").val();
			if( t > 0) throw new Exception("There are unresolved findings. You need to send this for revision");

			//if there is no application number generated yet, generate a new one.
			def appno = appEm.find( [objid: p.refid ] ).select("appno").val();
			if(!appno ) {
				appSvc.generateAppNo( [schemaname: "building_permit", appid: p.refid ] );
			}
			/*
			def c = rpuEm.find( [appid: p.refid ]).where("taxdeclarationid IS NULL").exists();
			if( c ) throw new Exception("Please generate the tax declaration documents ");
			c = rpuEm.find( [appid: p.refid ]).where("truecopycertid IS NULL").exists();
			if( c ) throw new Exception("Please generate the tax declaration documents ");
			*/
		}
		else if( p.taskstate.matches("zoning-verification|verification") ) {
			//check if there are no open findings
			def t = findingEm.find( [appid: p.refid ] ).select("c:{COUNT(*)}").where("state=2").val();
			if( t > 0) throw new Exception("There are unresolved findings. Send this for revision");
		}
		else if( p.taskstate == "assessment") {
			def c = feeEm.find( [appid: p.refid ]).select("c:{COUNT(*)}").val();
			if( c == 0 )
				throw new Exception("There must be at least one fee");		
		}
	}

	/* *********************************************************************
	//Evaluation-related triggers
	************************************************************************ */
	private void fireSectionWorkflow( refid, filter, action ) {
		def list = vwSectionEm.select("objid,taskid").find( [appid: refid ] ).where( filter ).list();
		if( list ) {
			def dt = dateSvc.getServerDate();
			list.each {
				def f = [:];
				f.processname = 'building_permit_section';
				f.refid = it.objid;
				f.taskid = it.taskid;
				f.startdate = dt;
				f.action = action;
				f.info = [:];
				wfSvc.signal(f);	
			}		
		}
	}

	//approve. fire section evaluations for zoning and trade evaluation
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'approve' }" ) 
	public void approveEvaluationTasks( def evt ) {
		def p = evt.args[0];
		def result = evt.result;
		if(!result.state.matches('zoning-evaluation|trade-evaluation')) return;

		def appid = p.refid;
		//start the next evaluation tasks. fire evaluations for required sections as well as optional that has existing ancillary 
		def mlist = sectionEm.where(" buildingpermitstate = :state  AND optional=0 ", [state: result.state] ).list()*.objid;
		//throw new Exception("state is " + mlist );

		//find sections that are optional and check if it has ancillary 
		def olist = sectionEm.where(" buildingpermitstate = :state AND optional=1 ", [state: result.state] ).list()*.objid;
		//throw new Exception("list trigger is " + olist);
		def alist = vwAncillaryEm.find( [appid: appid ] ).list()*.sectionid;
		olist.each {
			if( alist.contains(it) ) mlist << it;
		}

		if( mlist ) {
			def dt = dateSvc.getServerDate();
			mlist.each {
				//create each evaluation but check first if task exists
				def m = [appid: appid, typeid: it ]
				boolean b = evalEm.find( m ).exists();
				if(!b) {
					m = evalEm.create( m );
					def f = [:];
					f.processname = 'building_permit_section';
					f.refid = m.objid;
					f.startdate = dt;
					f.info = [ type: it ];
					wfSvc.start(f);				
				}
			}
		}		
	}

	//for-reactivation. check if there are evaluations where the task state is for-revision and reactivate each
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'reactivate' }" ) 
	public void reactivateEvaluationTasks( def evt ) {
		def p = evt.args[0];
		if( p.taskstate == "requirement-revision") {
			//do nothing special
		}
		else if(p.taskstate.matches( "zoning-evaluation-revision|trade-evaluation-revision") ) {
			def ids = findingEm.find( [appid: p.refid ] ).where("supersederid IS NULL AND state=2").groupBy("parentid").list()?.parentid;
			def strids = "('" + ids.join("','") + "')";			
			fireSectionWorkflow( p.refid, " objid IN " + strids, "reactivate" );	
		}
	}

	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'post-payment' }" ) 
	public void postPaymentTasks( def evt ) {
		def p = evt.args[0];
		def appid = p.refid;
		def dt = dateSvc.getServerDate();
		//find first sections where state is obo-processing. If type.issuepermit = 1 then move task to for releasing 
		def openList = vwSectionEm.find( [appid: appid ] ).where("task.state = 'obo-processing' ").list();
		openList.each {
			def f = [:];
			f.processname = 'building_permit_section';
			f.refid = it.objid;
			f.startdate = dt;
			f.info = it;
			f.taskid = it.taskid;
			f.action = (it.type.issuepermit == 1 ) ? "send-for-releasing" : "end";
			wfSvc.signal(f);	
		}
	}

	//release process. Make sure there is at least one building_permit_issuance
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].taskstate == 'releasing' && args[0].action == 'release' }" ) 
	public void doActionBeforeRelease( def evt ) {
		def p = evt.args[0];
		def appid = p.refid;
		def permitno = appEm.find( [objid: appid ] ).select("permitno").val();
		if(!permitno) throw new Exception("Permit no is required. ");
	}

	


} 