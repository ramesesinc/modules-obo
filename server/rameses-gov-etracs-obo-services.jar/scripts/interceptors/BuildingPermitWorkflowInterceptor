import com.rameses.annotations.*; 

/* ******************************************************************************************************
Notes:
The ff. are generic actions with similar related actions
1. send-for-verification = do nothing special; this action is triggered by the system when all evaluations are complete
2. send-for-revision = invoked by OBO verifier. triggers all email messages
3. reactivate - to be invoked by OBO receiving
approve - invoked by OBO Verifier. 
******************************************************************************************************* */
class BuildingPermitWorkflowInterceptor { 

	@Service("WorkflowTaskService")
	def wfSvc;

	@Service("DateService")
	def dateSvc;

	@Service("SequenceService")
	def seqSvc;

	@Service("AppnoGeneratorService")
	def appNoSvc;


	@DataContext("building_permit_evaluation")
	def evalEm;

	@DataContext("vw_building_permit_evaluation")
	def vwEvalEm;

	@DataContext("obo_evaluation_type")
	def evalTypeEm;

	@DataContext("building_permit_requirement")
	def reqEm;

	@DataContext("building_permit")
	def appEm;

	@DataContext("building_permit_ancillary")
	def ancillaryEm;

	@DataContext("vw_building_permit")
	def vwAppEm;

	@DataContext("building_permit_finding")
	def findingEm;

	@DataContext("building_permit_fee")
	def feeEm;

	/* *********************************************************************
	//Evaluation-related triggers
	************************************************************************ */
	private void fireEvaluationWorkflow( refid, filter, action ) {
		def list = vwEvalEm.select("objid,taskid").find( [appid: refid ] ).where( filter ).list();
		if( list ) {
			def dt = dateSvc.getServerDate();
			list.each {
				def f = [:];
				f.processname = 'building_permit_evaluation';
				f.refid = it.objid;
				f.taskid = it.taskid;
				f.startdate = dt;
				f.action = action;
				f.info = [:];
				wfSvc.signal(f);	
			}		
		}
	}

	//move all evaluations from for-verification to for-revision. For those that do not have issues send for approval.
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-revision' }") 
	public void sendEvaluationTaskForRevision( def evt ) {
		def p = evt.args[0];

		//check first findings that are yet open. These are tasks that need to be sent-for-revision
		def list = findingEm.find( [appid: p.refid ] ).where("checked = 0").list();
		def inIds = " objid IN ('" + list*.parentid.join("','") + "') ";
		def notInIds = " objid NOT IN ('" + list*.parentid.join("','") + "') AND task.state = 'for-verification' ";

		fireEvaluationWorkflow( p.refid, inIds, "send-for-revision" );
		fireEvaluationWorkflow( p.refid, notInIds, "approve" );
	}

	//for-reactivation. check if there are evaluations where the task state is for-revision and reactivate each
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'reactivate' }" ) 
	public void reactivateEvaluationTasks( def evt ) {
		def p = evt.args[0];
		fireEvaluationWorkflow( p.refid, " task.state = 'for-revision' ", "reactivate" );
	}

	//approve. check if there are evaluations where the task state is for-revision and reactivate each
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'approve' }" ) 
	public void approveEvaluationTasks( def evt ) {
		def p = evt.args[0];
		def result = evt.result;
		fireEvaluationWorkflow( p.refid, " task.state = 'for-verification' ", "approve" );

		//start the next evaluation tasks. fire evaluations for non-ancillary as well as those for ancillary
		def appid = p.refid;
		def pstate = [state: result.state];
		def list1 = evalTypeEm.where("activationstate = :state AND ancillarypermitid IS NULL ", pstate ).list()*.objid;
		def list2 = ancillaryEm.select("type.evaluationtypeid").find( [appid: appid ] ).where( "type.activationstate = :state", pstate ).list()*.type.evaluationtypeid;
		def mlist = list1 + list2;
		if( mlist ) {
			def dt = dateSvc.getServerDate();
			mlist.each {
				//create each evaluation but check first if task exists
				def m = [appid: appid, typeid: it ]
				boolean b = evalEm.find( m ).where("taskid IS NULL").exists();
				if(!b) {
					m = evalEm.create( m );
					def f = [:];
					f.processname = 'building_permit_evaluation';
					f.refid = m.objid;
					f.startdate = dt;
					f.info = [ type: it ];
					wfSvc.start(f);				
				}
			}
		}		
	}

	/* *********************************************************************
	//Specific before action tasks
	************************************************************************ */
	//Check prior to send-for-revision. There must be at least one finding
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-revision' }") 
	public void doActionBeforeRevision( def evt ) {
		def p = evt.args[0];
		if(p.taskstate == "receiving") {
			def c = reqEm.select("c:{COUNT(*)}").find([appid:p.refid]).where("checked=0 AND remarks IS NULL").val();
			if( c>0) throw new Exception("Please ensure that all requirements have remarks");
		}
		else {
			//check there must be at least one finding
			def c = findingEm.find( [appid: p.refid ] ).select("c:{COUNT(*)}").where("checked=0").val();
			if( c == 0) throw new Exception("There must be at least one finding");
		}
	}
	//This is the part where you need to check for application specific routines
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'approve' }") 
	public void doActionBeforeApproval( def evt ) {
		def p = evt.args[0];

		//check if there are open findings
		def t = findingEm.find( [appid: p.refid ] ).select("c:{COUNT(*)}").where("checked=0").val();
		if( t > 0) throw new Exception("All findings must be resolved first.");

		if(p.taskstate == "receiving") {
			def c = reqEm.select("c:{COUNT(*)}").find([appid:p.refid]).where("checked=0").val();
			if( c>0) throw new Exception("Please check first all requirements");
		}
		else if( p.to == "payment") {
			def c = feeEm.find( [appid: p.refid ]).select("c:{COUNT(*)}").val();
			if( c == 0 )
				throw new Exception("There must be at least one fee");		
		}
	}

	//application specific routines after worksflow step
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'approve' }") 
	public void doActionsAfterApproval( def evt ) {
		def p = evt.args[0];
		def result = evt.result;
		def appid = p.refid;

		if( p.taskstate == "receiving") {
			//update the appno first
			int nextNo = seqSvc.getNextSeries( "OBO_BUILDING_APP");
			def appno = appNoSvc.generate( "BP-[yyyyMM]-[%05d]", nextNo  );
			def u = [:];
			u.appdate = dateSvc.getServerDate();
			u.appno = appno;
			appEm.find( [objid: appid ] ).update( u );
		}
		
	}


} 