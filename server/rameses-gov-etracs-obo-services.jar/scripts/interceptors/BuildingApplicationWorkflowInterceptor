import com.rameses.annotations.*;
import java.rmi.server.*;

/* ******************************************************************************************************
Notes:
The ff. are generic actions with similar related actions
1. send-for-verification = do nothing special; this action is triggered by the system when all evaluations are complete
2. send-for-revision = invoked by OBO verifier. triggers all email messages
3. reactivate - to be invoked by OBO receiving
approve - invoked by OBO Verifier. 
******************************************************************************************************* */
class BuildingApplicationWorkflowInterceptor { 


	@DataContext("building_evaluation")
	def evalEm;

	@DataContext("vw_building_evaluation")
	def vwEvalEm;

	@DataContext("building_permit")
	def appEm;

	@DataContext("vw_building_permit")
	def vwAppEm;

	@DataContext("building_permit_rpu")
	def rpuEm;

	@DataContext("building_permit_requirement")
	def reqEm;

	@DataContext("building_evaluation_finding")
	def findingEm;

	@DataContext("building_permit_fee")
	def feeEm;

	@DataContext("obo_control")
	def issuanceEm;

	@DataContext("obo_doctype")
	def doctypeEm;

	@DataContext("building_permit_doc")
	def subdocEm;

	@Service("WorkflowTaskService")
	def wfSvc;

	@Service("OboNotificationService")
    def notificationSvc;

	@Service("DateService")
	def dateSvc;

	@Service("JasperEmailQueueService")
    def emailSvc;

	@Service("OboApplicationTransmittalService")
	def transmittalSvc;

    @Service("OboAppnoGeneratorService")
	def appSvc;

    // --- RECEIVING ---- //
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action=='send-for-requirement-verification' }") 
	public void doActionBeforeReceiving( def evt ) {
		def p = evt.args[0];
		def app = vwAppEm.find( [objid: p.refid ]).first();
		if(!app.txntype) throw new Exception("Transaction Type is required");
		def c = rpuEm.find( [appid: p.refid ]).where("taxclearanceid IS NULL").exists();
		if( c ) throw new Exception("Please generate the tax declaration documents first");
		c = rpuEm.find( [appid: p.refid ]).where("truecopycertid IS NULL").exists();
		if( c ) throw new Exception("Please generate the tax declaration documents first");
	}

    // --- REQUIREMENT VERIFICATION ---- //
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-requirement-revision' }") 
	public void doActionBeforeRequirementRevision( def evt ) {
		def p = evt.args[0];
		transmittalSvc.validateForRevision( [appid:p.refid, apptype: "building_permit", type:"requirement"] );
	}

	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-requirement-revision' }") 
	public void doActionAfterRequirementRevision( def evt ) {
		def p = evt.args[0];
		def r = evt.result;
		def trans = transmittalSvc.create( [taskid:r.taskid, appid:p.refid, apptype:"building_permit", type: "requirement" ] );
		def app = vwAppEm.find( [objid: p.refid]).first();
		emailSvc.send( [reportid:"building_requirement_transmittal", refid:trans.objid ]);	
	}

	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname =='building_permit' && args[0].action == 'approve-requirement' }")      
	public void doRequirementValidation( def evt ) { 
		def p = evt.args[0];
		//check if there are pending findings
		def t = reqEm.find( [appid: p.refid ] ).select("c:{COUNT(*)}").where("state=0").val();
		if( t > 0) throw new Exception("You must check first all requirements.");
		t = reqEm.find( [appid: p.refid ] ).select("c:{COUNT(*)}").where("state=2 AND supersederid IS NULL").val();
		if( t > 0) throw new Exception("There are unresolved requirements. Please click Send for revision instead");

		//generate the app no here
		def appno = appSvc.generate([controlnopattern:"building_permit_appno"]);

		appEm.find( [objid: p.refid ]).update( [appno: appno, appdate: dateSvc.getServerDate() ] );
		//immediately email claim stub after
		emailSvc.send( [reportid:"building_permit_claimstub", refid:p.refid]);
	}

    // --- ZONING AND TRADE EVALUATION ---- //
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-finding-revision' }") 
	public void doActionBeforeFindingRevision( def evt ) {
		def p = evt.args[0];
		transmittalSvc.validateForRevision( [appid:p.refid, apptype: "building_permit", type:"finding"] );
	}

	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-finding-revision' }") 
	public void doActionAfterFindingRevision( def evt ) {
		def p = evt.args[0];
		def r = evt.result;
		def trans = transmittalSvc.create( [taskid:r.taskid, appid:p.refid, apptype:"building_permit", type: "finding" ] );
		def app = vwAppEm.find( [objid: p.refid]).first();
		emailSvc.send( [reportid:"building_finding_transmittal", refid:trans.objid ]);	
	}

  
 	//approval of evaluation. 
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname =='building_permit' && args[0].action == 'approve-evaluation' }")
	public void doEvaluationValidation( def evt ) { 
		def p = evt.args[0];
		//check if there are pending findings
		def t = findingEm.find( [appid: p.refid ] ).select("c:{COUNT(*)}").where("state=2 AND supersederid IS NULL").val();
		if( t > 0) throw new Exception("There are unresolved findings. You need to send this for revision");
	}

	//trigger when entering evaluation state
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && result.state.matches('.*evaluation') && args[0].action != 'reactivate' }") 
	public void fireEvaluationSections( def evt ) {
		def p = evt.args[0];
		def r = evt.result;

		def appid = p.refid;
		def state = r.state;

		def mlist = evalEm.getEvaluationsToActivate( [appid: appid, state: state ] )*.objid;
		p._notificationlist = [];
		if( mlist ) {
			def dt = dateSvc.getServerDate();
			mlist.each {
				def m = [appid: appid, typeid: it ]
				m = evalEm.create( m );
				def f = [:];
				f.processname = 'building_evaluation';
				f.refid = m.objid;
				f.startdate = dt;
				f.info = [ type: it, appid: appid ];
				wfSvc.start(f);		

				//load notifications		
				p._notificationlist << 'building_evaluation:' + it.toLowerCase();
			}
		}	
	}

	//for-reactivation. check if there are evaluations where the task state is for-revision and reactivate each
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'reactivate' }" ) 
	public void reactivateEvaluationTasks( def evt ) {
		def p = evt.args[0];
		p._notificationlist = [];
		def list = vwEvalEm.select("objid,taskid,typeid").find( [appid: p.refid ] ).where( " task.state = 'for-revision' " ).list();
		if( list ) {
			def dt = dateSvc.getServerDate();
			list.each {
				def f = [:];
				f.processname = 'building_evaluation';
				f.refid = it.objid;
				f.taskid = it.taskid;
				f.startdate = dt;
				f.action = "reactivate";
				f.info = [:];
				wfSvc.signal(f);

				//load notifications		
				p._notificationlist <<  'building_evaluation:' + it.typeid.toLowerCase();	
			}		
		}
	}

	
	//check at least one fee
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'send-for-assessment-approval' }") 
	public void doActionBeforeSendAssessmentForApproval( def evt ) {
		def p = evt.args[0];
		def c = feeEm.find( [appid: p.refid ]).select("c:{COUNT(*)}").where("parentid IS NULL").val();
		if( c==null || c == 0 )
			throw new Exception("There must be at least one fee");		
	}

	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'approve-assessment' }") 
	public void doActionAfterApproveAssessment( def evt ) {
		def p = evt.args[0];
		//immediately send order of payment
		emailSvc.send( [reportid:"building_permit_assessment", refid:p.refid ]);			
	}

	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'post-payment' }" ) 
	public void postPaymentTasks( def evt ) {
		def p = evt.args[0];
		def appid = p.refid;
		def dt = dateSvc.getServerDate();

		//update the documents to state=1 which is for release
		p._notificationlist = [];

		subdocEm.find( [appid: appid ]).update([state:1]);
		def docList = subdocEm.find( [appid: appid]).where("doctype.issuetype = 2").list();		
		docList.each {
			p._notificationlist <<  'building_permit_doc:' + it.doctype.objid.toLowerCase();				
		}
	}

	//this should fire after all the tasks have been saved
	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0]._notificationlist!=null }", index=50000) 
	public void notifyOtherTasks( def evt ) {
		def p = evt.args[0];
		p._notificationlist.each {
			notificationSvc.notify( it );
		}
	}

	//release process. Make sure there is at least one building_permit_issuance
	@Before(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'release' }", index=0 )
	public void doActionBeforeRelease( def evt ) {
		def p = evt.args[0];
		def appid = p.refid;
		def docList = subdocEm.find( [appid: appid]).where("controlid IS NULL").select("doctype.title").list();
		if( docList ) {
			throw new Exception("The ff. documents are not yet issued: " + docList*.doctype.title.join("/n") );
		}		
	}

	@After(pattern="WorkflowTaskService.signal", eval="#{args[0].processname == 'building_permit' && args[0].action == 'release' }", index=0 ) 
	public void doActionAfterRelease( def evt ) {
		def p = evt.args[0];
		throw new Exception("releasing the building permit");
	}


} 