import com.rameses.annotations.*;
import com.rameses.util.*;
import java.rmi.server.*;
import obo.facts.*;
import java.text.*;
import treasury.utils.*;
import treasury.facts.*;

class OccupancyApplicationPersistenceService {
	
	@DataContext("vw_building_permit")
	def bldgPermitEm;

	@DataContext("occupancy_application_task")
	def appTaskEm;

	@DataContext("occupancy_permit")
	def permitEm;

	@DataContext("vw_occupancy_application")
	def vwAppEm;

	@DataContext("occupancy_application_entity")
	def entityEm;

	@DataContext("occupancy_application_subdoc")
	def subdocEm;

	@DataContext("occupancy_application_requirement")
	def reqEm;

	@DataContext("obo_requirement_type")
	def reqTypeEm;

	@DataContext("obo_doctype")
	def doctypeEm;

	@Service("DateService")
	def dateSvc;

	@Service("WorkflowTaskService")
	def wfSvc;

	@Service("OccupancyApplicationService")
	def appSvc;

    @Env
    def env;

 	@ProxyMethod
	public def findBldgPermit( def o ) {
		return bldgPermitEm.find( o ).first();
	}

 	@ProxyMethod
	public def create( def app ) {
		if(!app.appno) {
			app.appno = appSvc.generateAppNo([:]);
		}
		//check first all professionals if exist in the obo_professional table
		app.objid = "OCC" + new UID();

		//remove application before so it can be replaced
		app.txnmode = "CAPTURE";
		def newapp = appEm.create( app );

		//save applicant
		applicant.profileid = applicant.remove("objid");
		applicant.entitytype = applicant.type?.toLowerCase();
		applicant.resident = ( applicant.address?.type == "local" ) ? 1 : 0;
		applicant.appid = app.objid;
		applicant = entityEm.create( applicant );

		//save all documents that are auto create that does not exist above
		subdocEm.getSubdocsToAutoCreate( [apptype:'building', appid: newapp.objid ]).each {
			def sd = [:];
			sd.appid = app.objid;
			sd.doctype = [objid: it.objid];
			sd.amount = 0;
			sd.state = 0;
			subdocEm.create( sd );			
		}

		//calculate the cost first before receiving
		def dt = dateSvc.getServerDate();
		def param = [:];
		param.app = [apptype:app.apptype, totalfloorarea:app.totalfloorarea];
		param.occupancytype = app.occupancytype;
		def cost = costSvc.calc( param );

		//update applicant, cost and appid for info
		def u = [:];
		u.createdby = [objid: env.USERID, name: env.FULLNAME];
		u.dtcreated = dt;
		u.applicantid = applicant.objid;
		u.appid = app.objid;
		u.fixedcost = cost; 
		binfoEm.find( [objid: app.infoid ] ).update( u );

		//update the requirements
		def reqTypes = reqTypeEm.where("permittype = 'occupancy_application' ").list();
		reqTypes.each {
			def r = [:];
			r.appid = app.objid;
			r.state = 0;
			r.typeid = it.objid;
			r.type = [objid: it.objid];
			reqEm.create( r );
		}

		if( app.permitissued == true ) {
			def doctype = doctypeEm.find( [objid: "BUILDING_PERMIT"] ).first();
			def bp = [:];	
			bp.appid = app.objid;
			bp.controlno = app.permitno;
			bp.dtissued = app.permitdtissued;
			bp.expirydate = app.permitexpirydate;
			bp.issuedby = [ objid:env.USERID, name:env.FULLNAME];
			bp.infoid = binfo.objid;
			bp.state = 3;
			bp.template = doctype.template;
			bp.endorserid = doctype.endorserid;
			bp.approverid = doctype.approverid;
			bp.reportheader = doctype.reportheader;

			bp = permitEm.create( bp );
			//add end application task
			def atask = [:];
			atask.refid = app.objid;
			atask.state =  "end";
			atask.dtcreated = dateSvc.getServerDate();
			atask = appTaskEm.create( atask );
			appEm.find([objid:app.objid]).update( [ taskid: atask.taskid, issuanceid: bp.objid ] );
		}
		else {
			//fire the workflow to start the process
			def p = [:];
			p.processname = 'occupancy_application';
			p.refid = app.objid;
			p.startdate = dt;
			p.info = app;
			p.assignee = [objid:env.USERID, name:env.FULLNAME];		
			wfSvc.start(p);				
		}

		return app;
	}


	
}